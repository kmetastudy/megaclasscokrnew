
<script>
$(document).ready(function() {
    // ì„  ë§¤ì¹­ í€´ì¦ˆ ì „ìš© ì„¤ì •
    const LINE_CONFIG = {
        themes: {
            science: {
                keywords: ['ê³¼í•™', 'ì‹¤í—˜', 'í™”í•™', 'ë¬¼ë¦¬', 'ìƒë¬¼', 'ì—°êµ¬', 'ì´ë¡ ', 'ë²•ì¹™', 'ê°€ì„¤', 'ì›ì†Œ', 'ë¬¼ì§ˆ', 'ìƒíƒœ'],
                emojis: ['ğŸ”¬', 'âš—ï¸', 'ğŸ§ª', 'ğŸ”­', 'ğŸŒ¡ï¸', 'âš›ï¸', 'ğŸ§¬', 'ğŸ’Š', 'ğŸ¦ ', 'ğŸŒŒ'],
                particles: ['ğŸ”¬', 'âš—ï¸', 'ğŸ§ª', 'âš›ï¸', 'ğŸ’¡', 'ğŸŒŸ'],
                colors: ['rgba(33, 150, 243, 0.3)', 'rgba(3, 218, 198, 0.3)', 'rgba(0, 188, 212, 0.3)']
            },
            math: {
                keywords: ['ìˆ˜í•™', 'ê³„ì‚°', 'ê³µì‹', 'ë°©ì •ì‹', 'ê¸°í•˜', 'ëŒ€ìˆ˜', 'í™•ë¥ ', 'í†µê³„', 'í•¨ìˆ˜', 'ìˆ«ì'],
                emojis: ['â•', 'â–', 'âœ–ï¸', 'â—', 'ğŸ“', 'ğŸ“Š', 'ğŸ“ˆ', 'ğŸ”¢', 'âˆ‘', 'âˆ'],
                particles: ['â•', 'â–', 'âœ–ï¸', 'â—', 'ğŸ“', 'ğŸ”¢'],
                colors: ['rgba(255, 152, 0, 0.3)', 'rgba(255, 193, 7, 0.3)', 'rgba(255, 171, 0, 0.3)']
            },
            career: {
                keywords: ['ì§„ë¡œ', 'ì§ì—…', 'ì·¨ì—…', 'ë¯¸ë˜', 'ê¿ˆ', 'ëª©í‘œ', 'ê³„íš', 'ì„±ì¥', 'ë°œì „', 'ëŠ¥ë ¥'],
                emojis: ['ğŸ’¼', 'ğŸ‘”', 'ğŸ¯', 'ğŸ“ˆ', 'ğŸ†', 'ğŸš€', 'ğŸ’¡', 'ğŸŒŸ', 'ğŸ”¥', 'â­'],
                particles: ['ğŸ’¼', 'ğŸ¯', 'ğŸ“ˆ', 'ğŸ†', 'ğŸš€', 'ğŸ’¡'],
                colors: ['rgba(76, 175, 80, 0.3)', 'rgba(139, 195, 74, 0.3)', 'rgba(102, 187, 106, 0.3)']
            },
            social: {
                keywords: ['ì‚¬íšŒ', 'ì—­ì‚¬', 'ì •ì¹˜', 'ê²½ì œ', 'ë¬¸í™”', 'ì§€ë¦¬', 'ì¸ê¶Œ', 'ë¯¼ì£¼ì£¼ì˜', 'ì„ ê±°', 'íˆ¬í‘œ'],
                emojis: ['ğŸ‘¥', 'ğŸ›ï¸', 'ğŸ—³ï¸', 'ğŸ“Š', 'ğŸŒ', 'ğŸ´', 'ğŸ“œ', 'âš–ï¸', 'ğŸ•Šï¸', 'ğŸ¤'],
                particles: ['ğŸ‘¥', 'ğŸ›ï¸', 'ğŸ—³ï¸', 'ğŸŒ', 'ğŸ“Š', 'ğŸ¤'],
                colors: ['rgba(233, 30, 99, 0.3)', 'rgba(255, 64, 129, 0.3)', 'rgba(173, 20, 87, 0.3)']
            },
            default: {
                keywords: [],
                emojis: ['ğŸ”—', 'âœ¨', 'â­', 'ğŸŒŸ', 'ğŸ’«', 'ğŸ‰', 'ğŸŠ', 'ğŸŒˆ', 'ğŸ¦‹', 'ğŸŒº'],
                particles: ['ğŸ”—', 'âœ¨', 'â­', 'ğŸŒŸ', 'ğŸ’«', 'ğŸ‰'],
                colors: ['rgba(255, 255, 255, 0.3)', 'rgba(255, 107, 107, 0.3)', 'rgba(78, 205, 196, 0.3)']
            }
        },
        
        correctMessages: [
            "ğŸ‰ ì™„ë²½í•©ë‹ˆë‹¤! ëª¨ë“  ì—°ê²°ì´ ì •í™•í•´ìš”! ğŸ‘",
            "ì •ë‹µì´ì—ìš”! ğŸŒŸ í›Œë¥­í•œ ë§¤ì¹­ì´ì—ˆìŠµë‹ˆë‹¤!",
            "ë§ìŠµë‹ˆë‹¤! ğŸŠ ëª¨ë“  í•­ëª©ì„ ì˜¬ë°”ë¥´ê²Œ ì—°ê²°í–ˆì–´ìš”!",
            "ìµœê³ ì˜ˆìš”! ğŸ’¯ ì™„ë²½í•œ ì—°ê²°ì…ë‹ˆë‹¤!"
        ],
        
        incorrectMessages: [
            "ğŸ¤” ì¼ë¶€ ì—°ê²°ì´ í‹€ë ¸ì–´ìš”! ë‹¤ì‹œ í™•ì¸í•´ë³´ì„¸ìš”! ğŸ˜Š",
            "ì•„ì§ ì •ë‹µì´ ì•„ë‹ˆì—ìš”! ğŸ’ª ë‹¤ì‹œ ì‹œë„í•´ë³´ì„¸ìš”!",
            "ì¡°ê¸ˆ ë” ìƒê°í•´ë³¼ê¹Œìš”? ğŸ§ ë‹¤ì‹œ ì—°ê²°í•´ë³´ì„¸ìš”!",
            "ì•„ì‰¬ì›Œìš”! ğŸ˜Š í•œë²ˆ ë” ë„ì „í•´ë³´ì„¸ìš”!"
        ],
        
        partialMessages: [
            "ğŸ‘ ì¼ë¶€ ì •ë‹µì´ì—ìš”! ë‚˜ë¨¸ì§€ë„ ì—°ê²°í•´ë³´ì„¸ìš”!",
            "ğŸ¯ ì ˆë°˜ ì„±ê³µ! ì¡°ê¸ˆë§Œ ë” í˜ë‚´ì„¸ìš”!",
            "ğŸ’ª ì¢‹ì€ ì‹œì‘ì´ì—ìš”! ê³„ì† ë„ì „í•´ë³´ì„¸ìš”!",
            "ğŸŒŸ ë¶€ë¶„ ì •ë‹µ! ì™„ì „í•œ ì •ë‹µê¹Œì§€ ì¡°ê¸ˆ ë”!"
        ]
    };
    
    // ì „ì—­ ë³€ìˆ˜
    let lineIsAnswered = false;
    let selectedLeft = null;
    let connections = {};
    let tempLine = null;
    let isDrawingMode = false;
    let extractedItems = [];
    let questionText = '';
    let correctMatches = {};
    let hintUsed = false;
    let realTimeValidation = true;
    let currentScore = 0;
    let maxScore = 0;
    
    // ğŸš€ ì„  ë§¤ì¹­ í€´ì¦ˆ ì´ˆê¸°í™”
    function initializeLineQuiz() {
        if ($('#line-quiz-container').length === 0) return;
        
        console.log('ğŸš€ ì„  ë§¤ì¹­ í€´ì¦ˆ ì´ˆê¸°í™” ì‹œì‘');
        
        // 1. ê¸°ì¡´ HTML ì™„ì „íˆ ìˆ¨ê¸°ê¸° ë° ì •ë¦¬
        hideOriginalContent();
        
        // 2. ê¸°ì¡´ HTMLì—ì„œ ë¬¸ì œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
        extractQuestionText();
        
        // 3. ì„œë²„ì—ì„œ ì •ë‹µ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        loadCorrectAnswers();
        
        // 4. ë§¤ì¹­ ì•„ì´í…œ ë°ì´í„° ì„¤ì •
        setupMatchingData();
        
        // 5. ë¬¸ì œ í…ìŠ¤íŠ¸ ë¶„ì„í•˜ì—¬ í…Œë§ˆ ì„¤ì •
        const theme = detectThemeFromText(questionText);
        applyLineTheme(theme);
        
        // 6. íŒŒí‹°í´ ìƒì„±
        createLineParticles(theme);
        
        // 7. ìƒˆë¡œìš´ ë§¤ì¹­ ì•„ì´í…œ ìƒì„±
        createNewMatchingItems();
        
        // 8. ì´ë²¤íŠ¸ ì„¤ì •
        setupLineEvents();
        
        // 9. ì§„í–‰ë¥  ì´ˆê¸°í™”
        updateProgress();
        
        // 10. ê¸°ì¡´ ë‹µì•ˆ ë³µì›
        restoreLineAnswer();
        
        console.log('âœ… ì„  ë§¤ì¹­ í€´ì¦ˆ ì´ˆê¸°í™” ì™„ë£Œ');
        console.log(`ğŸ¨ í…Œë§ˆ: ${theme}`);
    }
    
    // ğŸš« ê¸°ì¡´ HTML ì™„ì „íˆ ìˆ¨ê¸°ê¸°
    function hideOriginalContent() {
        console.log('ğŸš« ê¸°ì¡´ HTML ì½˜í…ì¸  ìˆ¨ê¸°ê¸°');
        
        // ê¸°ì¡´ í€´ì¦ˆ ê´€ë ¨ ìš”ì†Œë“¤ì„ ëª¨ë‘ ìˆ¨ê¸°ê¸°
        $('.quiz-container').hide();
        $('.options-container').hide();
        $('.choice.answer').hide();
        $('.option-button').hide();
        
        // í•˜ë‹¨ì˜ ì¤‘ë³µ ë¦¬ìŠ¤íŠ¸ë“¤ë„ ìˆ¨ê¸°ê¸°
        $('div').filter(function() {
            const text = $(this).text();
            return text.includes('ê³ ì²´') || text.includes('ì•¡ì²´') || text.includes('ê¸°ì²´') || 
                   text.includes('ì¼ì •í•œ ëª¨ì–‘') || text.includes('í˜ëŸ¬ê°€ëŠ” ì„±ì§ˆ') || text.includes('ê³µê°„ì„ ì±„ì›€');
        }).not('#line-quiz-container').hide();
        
        // ê¸°ì¡´ ë§¤ì¹­ ì•„ì´í…œë“¤ ìˆ¨ê¸°ê¸°
        $('.match-item').not('#line-quiz-container .match-item').hide();
        
        console.log('âœ… ê¸°ì¡´ ì½˜í…ì¸  ìˆ¨ê¸°ê¸° ì™„ë£Œ');
    }
    
    // ğŸ” ë¬¸ì œ í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œ
    function extractQuestionText() {
        const questionSelectors = [
            '#question-text',
            '.question-box',
            '.quiz-container .question-text',
            '.quiz-container h1',
            '.question-box h1'
        ];
        
        for (let selector of questionSelectors) {
            const element = $(selector);
            if (element.length > 0) {
                let extractedText = element.text().trim();
                
                // HTMLì—ì„œ ì‹¤ì œ í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œ
                if (extractedText && extractedText.length > 5 && extractedText.length < 500) {
                    questionText = extractedText;
                    console.log(`âœ… ë¬¸ì œ í…ìŠ¤íŠ¸ ì¶”ì¶œ ì„±ê³µ: "${questionText}"`);
                    break;
                }
            }
        }
        
        if (!questionText || questionText.length < 5) {
            questionText = "ë‹¤ìŒ í•­ëª©ë“¤ì„ ì˜¬ë°”ë¥´ê²Œ ì—°ê²°í•´ë³´ì„¸ìš”!";
            console.log('âš ï¸ ê¸°ë³¸ ë¬¸ì œ í…ìŠ¤íŠ¸ ì‚¬ìš©');
        }
    }
    
    // ğŸ¯ ì„œë²„ì—ì„œ ì •ë‹µ ë°ì´í„° ë¡œë“œ
    function loadCorrectAnswers() {
        try {
            {% if slide.content.answer %}
            const answerData = JSON.parse('{{ slide.content.answer|escapejs }}');
            if (answerData && answerData.answer) {
                correctMatches = answerData.answer;
                maxScore = Object.keys(correctMatches).length;
                console.log('âœ… ì„œë²„ì—ì„œ ì •ë‹µ ë°ì´í„° ë¡œë“œ ì„±ê³µ:', correctMatches);
            } else {
                throw new Error('ì •ë‹µ ë°ì´í„° í˜•ì‹ ì˜¤ë¥˜');
            }
            {% else %}
            throw new Error('ì„œë²„ì— ì •ë‹µ ë°ì´í„°ê°€ ì—†ìŒ');
            {% endif %}
        } catch (e) {
            console.warn('âš ï¸ ì„œë²„ ì •ë‹µ ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨, ê¸°ë³¸ ì •ë‹µ ì‚¬ìš©:', e);
            // ê¸°ë³¸ ì •ë‹µ ë°ì´í„°
            correctMatches = {
                "left1": "right1",
                "left2": "right2", 
                "left3": "right3",
                "left4": "right4",
                "left5": "right5",
                "left6": "right6"
            };
            maxScore = Object.keys(correctMatches).length;
        }
        
        console.log('ğŸ¯ ì •ë‹µ ë§¤ì¹­:', correctMatches);
        console.log('ğŸ“Š ìµœëŒ€ ì ìˆ˜:', maxScore);
    }
    
    // ğŸ—ï¸ ë§¤ì¹­ ì•„ì´í…œ ë°ì´í„° ì„¤ì •
    function setupMatchingData() {
        console.log('ğŸ—ï¸ ë§¤ì¹­ ì•„ì´í…œ ë°ì´í„° ì„¤ì •');
        
        // ë¬¸ì œ í…ìŠ¤íŠ¸ ë¶„ì„í•´ì„œ ì•„ì´í…œ ì¶”ì¶œ
        if (questionText.includes('ë¬¼ì§ˆì˜ ìƒíƒœ')) {
            // ë¬¼ì§ˆì˜ ìƒíƒœ ë¬¸ì œ
            extractedItems = {
                leftItems: [
                    { id: "left1", text: "ğŸ§Š ê³ ì²´", emoji: "ğŸ§Š" },
                    { id: "left2", text: "ğŸ’§ ì•¡ì²´", emoji: "ğŸ’§" },
                    { id: "left3", text: "ğŸ’¨ ê¸°ì²´", emoji: "ğŸ’¨" }
                ],
                rightItems: [
                    { id: "right1", text: "ğŸ“ ì¼ì •í•œ ëª¨ì–‘", emoji: "ğŸ“" },
                    { id: "right2", text: "ğŸŒŠ í˜ëŸ¬ê°€ëŠ” ì„±ì§ˆ", emoji: "ğŸŒŠ" },
                    { id: "right3", text: "ğŸˆ ê³µê°„ì„ ì±„ì›€", emoji: "ğŸˆ" }
                ]
            };
            
            // ì •ë‹µ ë§¤ì¹­ë„ ìˆ˜ì •
            correctMatches = {
                "left1": "right1", // ê³ ì²´ -> ì¼ì •í•œ ëª¨ì–‘
                "left2": "right2", // ì•¡ì²´ -> í˜ëŸ¬ê°€ëŠ” ì„±ì§ˆ
                "left3": "right3"  // ê¸°ì²´ -> ê³µê°„ì„ ì±„ì›€
            };
            
        } else if (questionText.includes('ì˜ì–´') || questionText.includes('Apple')) {
            // ì˜ì–´ ë‹¨ì–´ ë¬¸ì œ
            extractedItems = {
                leftItems: [
                    { id: "left1", text: "ğŸ Apple", emoji: "ğŸ" },
                    { id: "left2", text: "ğŸ“š Book", emoji: "ğŸ“š" },
                    { id: "left3", text: "ğŸ± Cat", emoji: "ğŸ±" },
                    { id: "left4", text: "ğŸ¶ Dog", emoji: "ğŸ¶" }
                ],
                rightItems: [
                    { id: "right1", text: "ğŸ ì‚¬ê³¼", emoji: "ğŸ" },
                    { id: "right2", text: "ğŸ“– ì±…", emoji: "ğŸ“–" },
                    { id: "right3", text: "ğŸ± ê³ ì–‘ì´", emoji: "ğŸ±" },
                    { id: "right4", text: "ğŸ• ê°œ", emoji: "ğŸ•" }
                ]
            };
            
            correctMatches = {
                "left1": "right1", // Apple -> ì‚¬ê³¼
                "left2": "right2", // Book -> ì±…
                "left3": "right3", // Cat -> ê³ ì–‘ì´
                "left4": "right4"  // Dog -> ê°œ
            };
            
        } else {
            // ê¸°ë³¸ ë°ì´í„°
            extractedItems = {
                leftItems: [
                    { id: "left1", text: "í•­ëª© 1", emoji: "ğŸ”¹" },
                    { id: "left2", text: "í•­ëª© 2", emoji: "ğŸ”¸" },
                    { id: "left3", text: "í•­ëª© 3", emoji: "ğŸ”º" }
                ],
                rightItems: [
                    { id: "right1", text: "íŠ¹ì§• 1", emoji: "â­" },
                    { id: "right2", text: "íŠ¹ì§• 2", emoji: "âœ¨" },
                    { id: "right3", text: "íŠ¹ì§• 3", emoji: "ğŸ’«" }
                ]
            };
            
            correctMatches = {
                "left1": "right1",
                "left2": "right2",
                "left3": "right3"
            };
        }
        
        maxScore = Object.keys(correctMatches).length;
        console.log('ğŸ“‹ ë§¤ì¹­ ì•„ì´í…œ ë°ì´í„°:', extractedItems);
        console.log('ğŸ¯ ì •ë‹µ ë§¤ì¹­:', correctMatches);
    }
    
    // ğŸ¨ ë¬¸ì œ í…ìŠ¤íŠ¸ì—ì„œ í…Œë§ˆ ê°ì§€
    function detectThemeFromText(text) {
        let maxScore = 0;
        let detectedTheme = 'default';
        
        Object.keys(LINE_CONFIG.themes).forEach(theme => {
            const keywords = LINE_CONFIG.themes[theme].keywords;
            let score = 0;
            
            keywords.forEach(keyword => {
                if (text.includes(keyword)) {
                    score++;
                }
            });
            
            if (score > maxScore) {
                maxScore = score;
                detectedTheme = theme;
            }
        });
        
        console.log(`ğŸ¨ ê°ì§€ëœ í…Œë§ˆ: ${detectedTheme} (ì ìˆ˜: ${maxScore})`);
        return detectedTheme;
    }
    
    // ğŸª ì„  ë§¤ì¹­ í…Œë§ˆ ì ìš©
    function applyLineTheme(theme) {
        const container = $('#line-quiz-container');
        container.attr('data-theme', theme);
        
        if (LINE_CONFIG.themes[theme]) {
            const themeConfig = LINE_CONFIG.themes[theme];
            
            // ì¥ì‹ ì´ëª¨ì§€ ì„¤ì •
            $('#decoration1').text(themeConfig.emojis[0] || 'ğŸ”—');
            $('#decoration2').text(themeConfig.emojis[Math.floor(Math.random() * themeConfig.emojis.length)] || 'âœ¨');
        }
        
        // í€´ì¦ˆ ì œëª© ì„¤ì •
        const themeNames = {
            science: 'ê³¼í•™',
            math: 'ìˆ˜í•™',
            social: 'ì‚¬íšŒ',
            career: 'ì§„ë¡œ',
            default: 'ì¼ë°˜'
        };
        
        $('#quiz-title').text(`${themeNames[theme] || 'ì¼ë°˜'} ì„ ìœ¼ë¡œ ì—°ê²°í•˜ê¸° í€´ì¦ˆ`);
        
        // ë¬¸ì œ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        $('#question-text').html(questionText);
    }
    
    // âœ¨ íŒŒí‹°í´ ìƒì„±
    function createLineParticles(theme) {
        const particleContainer = $('#particles');
        const themeConfig = LINE_CONFIG.themes[theme];
        
        if (!themeConfig) return;
        
        particleContainer.empty();
        
        for (let i = 0; i < 15; i++) {
            const particle = $('<div>').addClass('particle');
            particle.css({
                'left': Math.random() * 100 + '%',
                'width': Math.random() * 8 + 4 + 'px',
                'height': Math.random() * 8 + 4 + 'px',
                'background-color': themeConfig.colors[Math.floor(Math.random() * themeConfig.colors.length)],
                'animation-delay': Math.random() * 15 + 's',
                'animation-duration': (Math.random() * 10 + 15) + 's'
            });
            
            // 30% í™•ë¥ ë¡œ í…Œë§ˆë³„ ì´ëª¨ì§€ íŒŒí‹°í´
            if (Math.random() < 0.3 && themeConfig.particles) {
                particle.text(themeConfig.particles[Math.floor(Math.random() * themeConfig.particles.length)]);
                particle.css({
                    'background-color': 'transparent',
                    'font-size': '20px',
                    'width': 'auto',
                    'height': 'auto'
                });
            }
            
            particleContainer.append(particle);
        }
    }
    
    // ğŸ¨ ìƒˆë¡œìš´ ë§¤ì¹­ ì•„ì´í…œ ìƒì„±
    function createNewMatchingItems() {
        console.log('ğŸ¨ ìƒˆë¡œìš´ ë§¤ì¹­ ì•„ì´í…œ ìƒì„± ì‹œì‘');
        
        const leftContainer = $('#left-items');
        const rightContainer = $('#right-items');
        
        // ê¸°ì¡´ ì•„ì´í…œë“¤ ì™„ì „íˆ ì œê±°
        leftContainer.empty();
        rightContainer.empty();
        
        // ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ ê°•ì œ ì„¤ì • (ì¢Œìš° ë°°ì¹˜ ë³´ì¥)
        leftContainer.css({
            'display': 'flex',
            'flex-direction': 'column',
            'gap': '20px',
            'width': '300px',
            'align-items': 'center'
        });
        
        rightContainer.css({
            'display': 'flex',
            'flex-direction': 'column',
            'gap': '20px',
            'width': '300px',
            'align-items': 'center'
        });
        
        // ë§¤ì¹­ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ ê°•ì œ ì„¤ì •
        $('#matching-container').css({
            'display': 'flex',
            'flex-direction': 'row',
            'justify-content': 'space-between',
            'align-items': 'center',
            'width': '100%',
            'max-width': '900px',
            'margin': '30px auto',
            'position': 'relative'
        });
        
        // ì™¼ìª½ ì•„ì´í…œ ìƒì„±
        extractedItems.leftItems.forEach((item, index) => {
            const itemElement = $('<div>')
                .addClass('match-item')
                .attr('id', `left-${item.id}`)
                .attr('data-item-id', item.id)
                .attr('data-side', 'left')
                .attr('data-index', index)
                .attr('tabindex', '0')
                .html(item.text)
                .css({
                    'background': getItemGradient(index, 'left'),
                    'transform': 'translateX(-20px)',
                    'opacity': '0',
                    'width': '250px',
                    'min-height': '70px',
                    'display': 'flex',
                    'align-items': 'center',
                    'justify-content': 'center',
                    'margin': '0 auto'
                });
            
            leftContainer.append(itemElement);
            
            // ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ë“±ì¥
            setTimeout(() => {
                itemElement.css({
                    'transform': 'translateX(0)',
                    'opacity': '1',
                    'transition': 'all 0.5s ease'
                });
            }, index * 200);
        });
        
        // ì˜¤ë¥¸ìª½ ì•„ì´í…œ ìƒì„±
        extractedItems.rightItems.forEach((item, index) => {
            const itemElement = $('<div>')
                .addClass('match-item')
                .attr('id', `right-${item.id}`)
                .attr('data-item-id', item.id)
                .attr('data-side', 'right')
                .attr('data-index', index)
                .attr('tabindex', '0')
                .html(item.text)
                .css({
                    'background': getItemGradient(index, 'right'),
                    'transform': 'translateX(20px)',
                    'opacity': '0',
                    'width': '250px',
                    'min-height': '70px',
                    'display': 'flex',
                    'align-items': 'center',
                    'justify-content': 'center',
                    'margin': '0 auto'
                });
            
            rightContainer.append(itemElement);
            
            // ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ë“±ì¥ (ì™¼ìª½ë³´ë‹¤ ì¡°ê¸ˆ ëŠ¦ê²Œ)
            setTimeout(() => {
                itemElement.css({
                    'transform': 'translateX(0)',
                    'opacity': '1',
                    'transition': 'all 0.5s ease'
                });
            }, (index * 200) + 600);
        });
        
        console.log('âœ¨ ìƒˆë¡œìš´ ë§¤ì¹­ ì•„ì´í…œ ìƒì„± ì™„ë£Œ');
    }
    
    // ğŸ¨ ì•„ì´í…œë³„ ê·¸ë¼ë””ì–¸íŠ¸ ìƒ‰ìƒ ìƒì„±
    function getItemGradient(index, side) {
        const colors = [
            ['#FF6B6B', '#FF8E8E'],
            ['#4ECDC4', '#6EDDD6'],
            ['#45B7D1', '#67C3DB'],
            ['#96CEB4', '#A8D5C4'],
            ['#FFEAA7', '#FFE58F'],
            ['#DDA0DD', '#E6B3E6'],
            ['#F093FB', '#F5CBFF'],
            ['#FFB347', '#FFCC70']
        ];
        
        const colorPair = colors[index % colors.length];
        return `linear-gradient(135deg, ${colorPair[0]}, ${colorPair[1]})`;
    }
    
    // ğŸ¯ ì´ë²¤íŠ¸ ì„¤ì •
    function setupLineEvents() {
        // ê¸°ì¡´ ì´ë²¤íŠ¸ ì œê±°
        $(document).off('click', '.match-item');
        $(document).off('touchstart', '.match-item');
        $(document).off('touchend', '.match-item');
        
        // ìƒˆë¡œìš´ ì´ë²¤íŠ¸ ì„¤ì •
        $(document).on('click', '.match-item[data-side="left"]', handleLeftItemClick);
        $(document).on('click', '.match-item[data-side="right"]', handleRightItemClick);
        
        // ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸
        $('#matching-container').on('mousemove', handleMouseMove);
        
        // í„°ì¹˜ ì´ë²¤íŠ¸
        $(document).on('touchstart', '.match-item', handleTouchStart);
        $(document).on('touchend', '.match-item', handleTouchEnd);
        
        // íŒíŠ¸ ë²„íŠ¼ ì´ë²¤íŠ¸
        $('#hint-button').on('click', showHint);
        
        // í‚¤ë³´ë“œ ì§€ì›
        $(document).on('keydown', '.match-item', handleKeydown);
        
        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ì—°ê²°ì„  ë‹¤ì‹œ ê·¸ë¦¬ê¸°
        $(window).on('resize', debounce(redrawAllLines, 300));
        
        console.log('ğŸ¯ ì´ë²¤íŠ¸ ì„¤ì • ì™„ë£Œ');
    }
    
    // ğŸ–±ï¸ ì™¼ìª½ ì•„ì´í…œ í´ë¦­ ì²˜ë¦¬
    function handleLeftItemClick(e) {
        if (lineIsAnswered) return;
        
        const itemId = $(this).attr('data-item-id');
        console.log('ğŸ–±ï¸ ì™¼ìª½ ì•„ì´í…œ í´ë¦­:', itemId);
        
        // ì§„ë™ í”¼ë“œë°±
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
        
        // ì´ë¯¸ ì—°ê²°ëœ ì•„ì´í…œì¸ì§€ í™•ì¸
        if (connections[itemId]) {
            removeConnection(itemId);
            return;
        }
        
        // ì´ì „ ì„ íƒ ì´ˆê¸°í™”
        $('.match-item').removeClass('selected');
        
        // í˜„ì¬ ì•„ì´í…œ ì„ íƒ
        $(this).addClass('selected');
        selectedLeft = itemId;
        isDrawingMode = true;
        
        // ì„ íƒ íš¨ê³¼
        createSelectionSparkle($(this));
        
        // ì„ì‹œ ì„  ì œê±°
        if (tempLine) {
            tempLine.remove();
            tempLine = null;
        }
        
        console.log('âœ… ì™¼ìª½ ì•„ì´í…œ ì„ íƒ ì™„ë£Œ:', itemId);
    }
    
    // ğŸ–±ï¸ ì˜¤ë¥¸ìª½ ì•„ì´í…œ í´ë¦­ ì²˜ë¦¬
    function handleRightItemClick(e) {
        if (lineIsAnswered || !selectedLeft) return;
        
        const rightId = $(this).attr('data-item-id');
        console.log('ğŸ–±ï¸ ì˜¤ë¥¸ìª½ ì•„ì´í…œ í´ë¦­:', rightId, 'ì„ íƒëœ ì™¼ìª½:', selectedLeft);
        
        // ì§„ë™ í”¼ë“œë°±
        if (navigator.vibrate) {
            navigator.vibrate([50, 50, 50]);
        }
        
        // ì´ë¯¸ ì—°ê²°ëœ ì˜¤ë¥¸ìª½ ì•„ì´í…œì¸ì§€ í™•ì¸
        const existingConnection = Object.keys(connections).find(key => connections[key] === rightId);
        if (existingConnection) {
            removeConnection(existingConnection);
        }
        
        // ì—°ê²° ìƒì„±
        createConnection(selectedLeft, rightId);
        
        // ì‹¤ì‹œê°„ ê²€ì¦
        if (realTimeValidation) {
            validateConnection(selectedLeft, rightId);
        }
        
        // ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
        $('.match-item').removeClass('selected');
        const currentSelectedLeft = selectedLeft;
        selectedLeft = null;
        isDrawingMode = false;
        
        // ì„ì‹œ ì„  ì œê±°
        if (tempLine) {
            tempLine.remove();
            tempLine = null;
        }
        
        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        updateProgress();
        
        // ëª¨ë“  ì—°ê²° ì™„ë£Œ í™•ì¸
        setTimeout(() => checkAllConnections(), 300);
        
        console.log('âœ… ì—°ê²° ìƒì„± ì™„ë£Œ:', currentSelectedLeft, 'â†’', rightId);
    }
    
    // ğŸ¨ ì—°ê²° ìƒì„±
    function createConnection(leftId, rightId) {
        console.log('ğŸ¨ ì—°ê²° ìƒì„±:', leftId, 'â†’', rightId);
        
        connections[leftId] = rightId;
        
        const leftElement = $(`#left-${leftId}`);
        const rightElement = $(`#right-${rightId}`);
        
        // ì•„ì´í…œ ìŠ¤íƒ€ì¼ ë³€ê²½
        leftElement.addClass('connected');
        rightElement.addClass('connected');
        
        // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
        drawConnectionLine(leftId, rightId);
        
        // ì—°ê²° íš¨ê³¼
        createConnectionEffect(leftElement, rightElement);
        
        console.log('âœ… ì—°ê²° ìƒì„± ì™„ë£Œ');
    }
    
    // ğŸ¨ ì—°ê²° ì œê±°
    function removeConnection(leftId) {
        const rightId = connections[leftId];
        if (!rightId) return;
        
        console.log('ğŸ—‘ï¸ ì—°ê²° ì œê±°:', leftId, 'â†’', rightId);
        
        delete connections[leftId];
        
        const leftElement = $(`#left-${leftId}`);
        const rightElement = $(`#right-${rightId}`);
        const lineElement = $(`#line-${leftId}-${rightId}`);
        
        // ì•„ì´í…œ ìŠ¤íƒ€ì¼ ë³µì›
        leftElement.removeClass('connected error partial-correct');
        rightElement.removeClass('connected error partial-correct');
        
        // ì—°ê²°ì„  ì œê±°
        if (lineElement.length) {
            lineElement.remove();
        }
        
        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        updateProgress();
        
        console.log('âœ… ì—°ê²° ì œê±° ì™„ë£Œ');
    }
    
    // ğŸ“ ì—°ê²°ì„  ê·¸ë¦¬ê¸°
    function drawConnectionLine(leftId, rightId) {
        console.log('ğŸ“ ì—°ê²°ì„  ê·¸ë¦¬ê¸°:', leftId, 'â†’', rightId);
        
        const svg = $('#connection-svg');
        const leftElement = $(`#left-${leftId}`);
        const rightElement = $(`#right-${rightId}`);
        
        if (!leftElement.length || !rightElement.length) {
            console.warn('âš ï¸ ì—°ê²°ì„  ê·¸ë¦¬ê¸° ì‹¤íŒ¨: ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ', leftId, rightId);
            return;
        }
        
        // SVG ì»¨í…Œì´ë„ˆ í™•ì¸
        if (!svg.length) {
            console.warn('âš ï¸ SVG ì»¨í…Œì´ë„ˆë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
            return;
        }
        
        const leftRect = leftElement[0].getBoundingClientRect();
        const rightRect = rightElement[0].getBoundingClientRect();
        const svgRect = svg[0].getBoundingClientRect();
        
        // ì‹œì‘ì ê³¼ ëì  ê³„ì‚° (ë°•ìŠ¤ì˜ ì¤‘ì•™)
        const startX = leftRect.right - svgRect.left;
        const startY = leftRect.top + leftRect.height / 2 - svgRect.top;
        const endX = rightRect.left - svgRect.left;
        const endY = rightRect.top + rightRect.height / 2 - svgRect.top;
        
        console.log('ğŸ“ ì—°ê²°ì„  ì¢Œí‘œ:', {startX, startY, endX, endY});
        
        // ê¸°ì¡´ ì„  ì œê±°
        const existingLine = $(`#line-${leftId}-${rightId}`);
        if (existingLine.length) {
            existingLine.remove();
        }
        
        // ê³¡ì„  ê²½ë¡œ ìƒì„± (ë¶€ë“œëŸ¬ìš´ ë² ì§€ì–´ ê³¡ì„ )
        const controlX1 = startX + (endX - startX) * 0.3;
        const controlY1 = startY;
        const controlX2 = startX + (endX - startX) * 0.7;
        const controlY2 = endY;
        
        const pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
        
        // SVG path ìƒì„±
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('class', 'connection-line');
        path.setAttribute('id', `line-${leftId}-${rightId}`);
        path.setAttribute('data-left', leftId);
        path.setAttribute('data-right', rightId);
        
        svg[0].appendChild(path);
        
        // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
        try {
            const pathLength = path.getTotalLength();
            path.style.strokeDasharray = pathLength;
            path.style.strokeDashoffset = pathLength;
            
            // ì„  ê·¸ë¦¬ê¸° ì• ë‹ˆë©”ì´ì…˜
            $(path).animate({
                'stroke-dashoffset': 0
            }, 800, function() {
                path.style.strokeDasharray = 'none';
            });
        } catch (e) {
            console.warn('âš ï¸ ì—°ê²°ì„  ì• ë‹ˆë©”ì´ì…˜ ì‹¤íŒ¨:', e);
        }
        
        console.log('âœ… ì—°ê²°ì„  ê·¸ë¦¬ê¸° ì™„ë£Œ');
    }
    
    // ğŸ¨ ì„ì‹œ ì„  ê·¸ë¦¬ê¸° (ë§ˆìš°ìŠ¤ ë”°ë¼ë‹¤ë‹ˆëŠ” ì„ )
    function handleMouseMove(e) {
        if (!isDrawingMode || !selectedLeft) return;
        drawTempLine(e);
    }
    
    function drawTempLine(e) {
        const svg = $('#connection-svg');
        const leftElement = $(`#left-${selectedLeft}`);
        
        if (!leftElement.length || !svg.length) return;
        
        const leftRect = leftElement[0].getBoundingClientRect();
        const svgRect = svg[0].getBoundingClientRect();
        
        const startX = leftRect.right - svgRect.left;
        const startY = leftRect.top + leftRect.height / 2 - svgRect.top;
        const endX = e.clientX - svgRect.left;
        const endY = e.clientY - svgRect.top;
        
        // ê¸°ì¡´ ì„ì‹œ ì„  ì œê±°
        if (tempLine) {
            tempLine.remove();
        }
        
        // ê³¡ì„  ê²½ë¡œ ìƒì„±
        const controlX1 = startX + (endX - startX) * 0.3;
        const controlY1 = startY;
        const controlX2 = startX + (endX - startX) * 0.7;
        const controlY2 = endY;
        
        const pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
        
        // SVG path ìƒì„±
        tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        tempLine.setAttribute('d', pathData);
        tempLine.setAttribute('class', 'connection-line temp');
        
        svg[0].appendChild(tempLine);
    }
    
    // ë‚˜ë¨¸ì§€ í•¨ìˆ˜ë“¤ (ê²€ì¦, ì§„í–‰ë¥ , íŒíŠ¸, ì±„ì , ì• ë‹ˆë©”ì´ì…˜ ë“±)
    
    // ğŸ” ì‹¤ì‹œê°„ ì—°ê²° ê²€ì¦
    function validateConnection(leftId, rightId) {
        const isCorrect = correctMatches[leftId] === rightId;
        const leftElement = $(`#left-${leftId}`);
        const rightElement = $(`#right-${rightId}`);
        const lineElement = $(`#line-${leftId}-${rightId}`);
        
        if (isCorrect) {
            // ì •ë‹µ í‘œì‹œ
            leftElement.addClass('connected').removeClass('error');
            rightElement.addClass('connected').removeClass('error');
            lineElement.addClass('connected').removeClass('error');
            
            // ì •ë‹µ íš¨ê³¼
            createCorrectEffect(leftElement, rightElement);
            playCorrectSound();
            
            // ì ìˆ˜ ì¦ê°€
            currentScore++;
            
        } else {
            // ì˜¤ë‹µ í‘œì‹œ
            leftElement.addClass('error').removeClass('connected');
            rightElement.addClass('error').removeClass('connected');
            lineElement.addClass('error').removeClass('connected');
            
            // ì˜¤ë‹µ íš¨ê³¼
            createErrorEffect(leftElement, rightElement);
            playErrorSound();
            
            // 3ì´ˆ í›„ ì˜¤ë‹µ í‘œì‹œ ì œê±°
            setTimeout(() => {
                leftElement.removeClass('error');
                rightElement.removeClass('error');
                lineElement.removeClass('error');
            }, 3000);
        }
        
        console.log('ğŸ” ì‹¤ì‹œê°„ ê²€ì¦:', leftId, 'â†’', rightId, isCorrect ? 'âœ…' : 'âŒ');
    }
    
    // ğŸ“Š ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
    function updateProgress() {
        const totalConnections = Object.keys(correctMatches).length;
        const currentConnections = Object.keys(connections).length;
        const progressPercent = Math.round((currentConnections / totalConnections) * 100);
        
        $('#progress-text').text(`${currentConnections}/${totalConnections}`);
        $('#progress-fill').css('width', progressPercent + '%');
        
        // ì§„í–‰ë¥ ì— ë”°ë¥¸ ìƒ‰ìƒ ë³€í™”
        const progressFill = $('#progress-fill');
        if (progressPercent === 100) {
            progressFill.css('background', 'linear-gradient(90deg, #4CAF50, #66BB6A)');
        } else if (progressPercent >= 50) {
            progressFill.css('background', 'linear-gradient(90deg, #FF9800, #FFB74D)');
        } else {
            progressFill.css('background', 'linear-gradient(90deg, #2196F3, #64B5F6)');
        }
        
        console.log('ğŸ“Š ì§„í–‰ë¥  ì—…ë°ì´íŠ¸:', currentConnections, '/', totalConnections);
    }
    
    // ğŸ’¡ íŒíŠ¸ í‘œì‹œ
    function showHint() {
        if (hintUsed || lineIsAnswered) return;
        
        // ì—°ê²°ë˜ì§€ ì•Šì€ ì²« ë²ˆì§¸ ì •ë‹µ ìŒ ì°¾ê¸°
        let hintPair = null;
        for (let leftId in correctMatches) {
            if (!connections[leftId]) {
                hintPair = { left: leftId, right: correctMatches[leftId] };
                break;
            }
        }
        
        if (!hintPair) return;
        
        const leftElement = $(`#left-${hintPair.left}`);
        const rightElement = $(`#right-${hintPair.right}`);
        
        // íŒíŠ¸ ì• ë‹ˆë©”ì´ì…˜
        leftElement.addClass('hint');
        rightElement.addClass('hint');
        
        setTimeout(() => {
            leftElement.removeClass('hint');
            rightElement.removeClass('hint');
        }, 4500);
        
        hintUsed = true;
        $('#hint-button').css('opacity', '0.5').prop('disabled', true);
        
        console.log('ğŸ’¡ íŒíŠ¸ í‘œì‹œ:', hintPair.left, 'â†’', hintPair.right);
    }
    
    // âœ… ëª¨ë“  ì—°ê²° ì™„ë£Œ í™•ì¸
    function checkAllConnections() {
        if (lineIsAnswered) return;
        
        const totalConnections = Object.keys(correctMatches).length;
        const currentConnections = Object.keys(connections).length;
        
        if (currentConnections >= totalConnections) {
            // 1ì´ˆ í›„ ì±„ì 
            setTimeout(() => {
                checkAnswers();
            }, 1000);
        }
    }
    
    // ğŸ“ ì •ë‹µ í™•ì¸ ë° ì±„ì 
    function checkAnswers() {
        if (lineIsAnswered) return;
        
        lineIsAnswered = true;
        
        let correctCount = 0;
        const totalCount = Object.keys(correctMatches).length;
        
        // ê° ì—°ê²°ì„ í™•ì¸í•˜ê³  ì‹œê°ì  í”¼ë“œë°± ì œê³µ
        Object.keys(connections).forEach(leftId => {
            const rightId = connections[leftId];
            const isCorrect = correctMatches[leftId] === rightId;
            
            const leftElement = $(`#left-${leftId}`);
            const rightElement = $(`#right-${rightId}`);
            const lineElement = $(`#line-${leftId}-${rightId}`);
            
            if (isCorrect) {
                correctCount++;
                // ì •ë‹µ í‘œì‹œ
                leftElement.addClass('connected').removeClass('error partial-correct');
                rightElement.addClass('connected').removeClass('error partial-correct');
                lineElement.addClass('connected').removeClass('error');
            } else {
                // ì˜¤ë‹µ í‘œì‹œ
                leftElement.addClass('error').removeClass('connected partial-correct');
                rightElement.addClass('error').removeClass('connected partial-correct');
                lineElement.addClass('error').removeClass('connected');
            }
        });
        
        // ìµœì¢… ì ìˆ˜ ê³„ì‚°
        const finalScore = Math.round((correctCount / totalCount) * 100);
        const isAllCorrect = correctCount === totalCount;
        const isPartialCorrect = correctCount > 0 && correctCount < totalCount;
        
        // ê²°ê³¼ ì²˜ë¦¬
        if (isAllCorrect) {
            handleCorrectAnswer(finalScore);
        } else if (isPartialCorrect) {
            handlePartialAnswer(finalScore, correctCount, totalCount);
        } else {
            handleIncorrectAnswer();
        }
        
        // ì„œë²„ë¡œ ê²°ê³¼ ì „ì†¡
        sendLineAnswerToServer(connections, isAllCorrect, finalScore);
        
        console.log('ğŸ“ ì±„ì  ì™„ë£Œ:', correctCount, '/', totalCount, 'ì ìˆ˜:', finalScore);
    }
    
    // ë‚˜ë¨¸ì§€ í•¨ìˆ˜ë“¤ (ê²°ê³¼ ì²˜ë¦¬, ì• ë‹ˆë©”ì´ì…˜, ì„œë²„ í†µì‹  ë“±)
    
    // ğŸ‰ ì •ë‹µ ì²˜ë¦¬
    function handleCorrectAnswer(score) {
        const randomIndex = Math.floor(Math.random() * LINE_CONFIG.correctMessages.length);
        const message = LINE_CONFIG.correctMessages[randomIndex];
        
        showLineFeedback('correct', message, score);
        createSimpleFireworks();
        playSuccessSound();
        
        // 8ì´ˆ í›„ ë¦¬ì…‹
        setTimeout(() => {
            resetLineQuiz();
        }, 8000);
    }
    
    // ğŸ¯ ë¶€ë¶„ ì •ë‹µ ì²˜ë¦¬
    function handlePartialAnswer(score, correct, total) {
        const randomIndex = Math.floor(Math.random() * LINE_CONFIG.partialMessages.length);
        const message = LINE_CONFIG.partialMessages[randomIndex];
        
        showLineFeedback('partial', message, score, `${correct}/${total} ì •ë‹µ`);
        createSimpleFireworks();
        
        // 5ì´ˆ í›„ ë¦¬ì…‹
        setTimeout(() => {
            resetLineQuiz();
        }, 5000);
    }
    
    // âŒ ì˜¤ë‹µ ì²˜ë¦¬
    function handleIncorrectAnswer() {
        const randomIndex = Math.floor(Math.random() * LINE_CONFIG.incorrectMessages.length);
        const message = LINE_CONFIG.incorrectMessages[randomIndex];
        
        showLineFeedback('incorrect', message, 0);
        
        // 5ì´ˆ í›„ ë¦¬ì…‹
        setTimeout(() => {
            resetLineQuiz();
        }, 5000);
    }
    
    // ğŸ’¬ í”¼ë“œë°± í‘œì‹œ
    function showLineFeedback(type, message, score, extra = '') {
        const feedbackElement = $(`#feedback-${type}`);
        let feedbackHTML = message;
        
        if (score !== undefined) {
            feedbackHTML += `<div class="score-display">ì ìˆ˜: ${score}ì `;
            if (extra) {
                feedbackHTML += ` (${extra})`;
            }
            feedbackHTML += `</div>`;
        }
        
        feedbackElement.html(feedbackHTML).addClass('show');
    }
    
    // ğŸ† ê°„ë‹¨í•œ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
    function createSimpleFireworks() {
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                const particle = $('<div>').css({
                    'position': 'fixed',
                    'left': Math.random() * window.innerWidth + 'px',
                    'top': window.innerHeight + 'px',
                    'font-size': '24px',
                    'pointer-events': 'none',
                    'z-index': '9999'
                });
                
                particle.text(['ğŸ‰', 'âœ¨', 'ğŸŒŸ', 'ğŸŠ'][Math.floor(Math.random() * 4)]);
                $('body').append(particle);
                
                particle.animate({
                    top: -50 + 'px',
                    opacity: 0
                }, 1500, function() {
                    $(this).remove();
                });
            }, i * 100);
        }
    }
    
    // ğŸµ ê°„ë‹¨í•œ ì‚¬ìš´ë“œ íš¨ê³¼
    function playCorrectSound() {
        try {
            if (window.AudioContext || window.webkitAudioContext) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            }
        } catch (e) {
            console.log('ì‚¬ìš´ë“œ ì¬ìƒ ë¶ˆê°€:', e);
        }
    }
    
    function playErrorSound() {
        try {
            if (window.AudioContext || window.webkitAudioContext) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 200;
                oscillator.type = 'square';
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            }
        } catch (e) {
            console.log('ì‚¬ìš´ë“œ ì¬ìƒ ë¶ˆê°€:', e);
        }
    }
    
    function playSuccessSound() {
        try {
            if (window.AudioContext || window.webkitAudioContext) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const notes = [523, 659, 784]; // C, E, G
                
                notes.forEach((freq, index) => {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = freq;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                    }, index * 100);
                });
            }
        } catch (e) {
            console.log('ì‚¬ìš´ë“œ ì¬ìƒ ë¶ˆê°€:', e);
        }
    }
    
    // ğŸ“¡ ì„œë²„ë¡œ ê²°ê³¼ ì „ì†¡
    async function sendLineAnswerToServer(answers, isCorrect, score) {
        console.log('ğŸ“¡ ì„œë²„ë¡œ ê²°ê³¼ ì „ì†¡:', answers, isCorrect, score);
        
        const slideId = '{{ slide.id }}';
        const contentId = '{{ slide.content.id }}';
        
        try {
            const response = await $.ajax({
                url: '{% url "student:check_answer" %}',
                type: 'POST',
                data: {
                    'content_id': contentId,
                    'slide_id': slideId,
                    'student_answer': JSON.stringify(answers),
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                }
            });
            
            console.log('âœ… ì„œë²„ ì‘ë‹µ:', response);
            updateSubmissionStatus(response);
            
        } catch (error) {
            console.error('âŒ ì„œë²„ ì „ì†¡ ì˜¤ë¥˜:', error);
        }
    }
    
    // ğŸ“„ ì œì¶œ ìƒíƒœ ì—…ë°ì´íŠ¸
    function updateSubmissionStatus(response) {
        const wrapper = $('#submission-status-wrapper');
        const statusIcon = response.is_correct
            ? '<span class="text-green-600"><i class="fas fa-check-circle"></i> ì •ë‹µ</span>'
            : '<span class="text-red-600"><i class="fas fa-times-circle"></i> ì˜¤ë‹µ</span>';
        
        wrapper.html(`
            <div class="mt-4 text-sm text-gray-600">
                <i class="fas fa-info-circle mr-1"></i>
                ë§ˆì§€ë§‰ ì œì¶œ: ${response.submitted_at || 'ë°©ê¸ˆ ì „'}
                ${statusIcon}
                (ì ìˆ˜: ${response.score || 0}ì )
            </div>
        `);
    }
    
    // ğŸ”„ í€´ì¦ˆ ë¦¬ì…‹
    function resetLineQuiz() {
        {% if not is_already_correct %}
        console.log('ğŸ”„ í€´ì¦ˆ ë¦¬ì…‹');
        
        lineIsAnswered = false;
        selectedLeft = null;
        connections = {};
        isDrawingMode = false;
        hintUsed = false;
        currentScore = 0;
        
        // í”¼ë“œë°± ìˆ¨ê¸°ê¸°
        $('.feedback').removeClass('show');
        
        // ì•„ì´í…œ ìƒíƒœ ì´ˆê¸°í™”
        $('.match-item').removeClass('selected connected error partial-correct hint');
        
        // ì—°ê²°ì„  ì œê±°
        $('#connection-svg').empty();
        
        // ì„ì‹œ ì„  ì œê±°
        if (tempLine) {
            tempLine.remove();
            tempLine = null;
        }
        
        // íŒíŠ¸ ë²„íŠ¼ ë³µì›
        $('#hint-button').css('opacity', '1').prop('disabled', false);
        
        // ì§„í–‰ë¥  ì´ˆê¸°í™”
        updateProgress();
        
        // ì• ë‹ˆë©”ì´ì…˜ ì •ë¦¬
        $('body').find('[style*="position: fixed"]').remove();
        
        console.log('âœ… í€´ì¦ˆ ë¦¬ì…‹ ì™„ë£Œ');
        {% endif %}
    }
    
    // ğŸ”„ ê¸°ì¡´ ë‹µì•ˆ ë³µì›
    function restoreLineAnswer() {
        {% if existing_answer and slide.content_type.type_name == 'line_matching' %}
        try {
            const rawAnswer = '{{ existing_answer.answer|escapejs|default:"{}" }}';
            console.log('=== ì„  ë§¤ì¹­ ë‹µì•ˆ ë³µì› ì‹œì‘ ===');
            
            const answerData = JSON.parse(rawAnswer.replace(/'/g, '"'));
            
            if (answerData.selected_answer) {
                const savedConnections = answerData.selected_answer;
                lineIsAnswered = true;
                
                // ì—°ê²° ë³µì›
                Object.keys(savedConnections).forEach(leftId => {
                    const rightId = savedConnections[leftId];
                    
                    const leftElement = $(`#left-${leftId}`);
                    const rightElement = $(`#right-${rightId}`);
                    
                    if (leftElement.length && rightElement.length) {
                        connections[leftId] = rightId;
                        leftElement.addClass('connected');
                        rightElement.addClass('connected');
                        drawConnectionLine(leftId, rightId);
                    }
                });
                
                // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                updateProgress();
                
                // ì •ë‹µ/ì˜¤ë‹µ ìƒíƒœ í‘œì‹œ
                setTimeout(() => {
                    {% if is_already_correct %}
                    $('.match-item.connected').addClass('connected').removeClass('error');
                    $('.connection-line').addClass('connected').removeClass('error');
                    showLineFeedback('correct', 'ğŸ‰ ì´ì „ ì œì¶œ: ì™„ë²½í•œ ì—°ê²°ì…ë‹ˆë‹¤!', 100);
                    {% else %}
                    $('.match-item.connected').addClass('error').removeClass('connected');
                    $('.connection-line').addClass('error').removeClass('connected');
                    showLineFeedback('incorrect', 'ğŸ’ª ì´ì „ ì œì¶œ: ì¼ë¶€ ì—°ê²°ì„ ë‹¤ì‹œ í™•ì¸í•´ë³´ì„¸ìš”!');
                    {% endif %}
                }, 500);
            }
        } catch (e) {
            console.error('âŒ ë‹µì•ˆ ë³µì› ì˜¤ë¥˜:', e);
        }
        {% endif %}
    }
    
    // ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    function redrawAllLines() {
        Object.keys(connections).forEach(leftId => {
            const rightId = connections[leftId];
            drawConnectionLine(leftId, rightId);
        });
    }
    
    function createSelectionSparkle(element) {
        const rect = element[0].getBoundingClientRect();
        for (let i = 0; i < 3; i++) {
            const sparkle = $('<div>').css({
                'position': 'fixed',
                'left': rect.left + rect.width/2 + 'px',
                'top': rect.top + rect.height/2 + 'px',
                'width': '4px',
                'height': '4px',
                'background': '#FFD700',
                'border-radius': '50%',
                'pointer-events': 'none',
                'z-index': '9999'
            });
            
            $('body').append(sparkle);
            
            const angle = (i / 3) * 2 * Math.PI;
            const distance = 25;
            const endX = rect.left + rect.width/2 + Math.cos(angle) * distance;
            const endY = rect.top + rect.height/2 + Math.sin(angle) * distance;
            
            sparkle.animate({
                left: endX + 'px',
                top: endY + 'px',
                opacity: 0
            }, 300, function() {
                $(this).remove();
            });
        }
    }
    
    function createConnectionEffect(leftElement, rightElement) {
        [leftElement, rightElement].forEach(element => {
            element.addClass('touch-active');
            setTimeout(() => {
                element.removeClass('touch-active');
            }, 200);
        });
    }
    
    function createCorrectEffect(leftElement, rightElement) {
        [leftElement, rightElement].forEach(element => {
            const originalBackground = element.css('background');
            element.css('background', 'linear-gradient(135deg, #4CAF50, #66BB6A)');
            setTimeout(() => {
                element.css('background', originalBackground);
            }, 600);
        });
    }
    
    function createErrorEffect(leftElement, rightElement) {
        [leftElement, rightElement].forEach(element => {
            element.addClass('error');
        });
    }
    
    // í„°ì¹˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
    let touchStartItem = null;
    
    function handleTouchStart(e) {
        if (lineIsAnswered) return;
        
        touchStartItem = this;
        $(this).addClass('touch-active');
        
        e.preventDefault();
    }
    
    function handleTouchEnd(e) {
        if (!touchStartItem) return;
        
        const touch = e.originalEvent.changedTouches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        
        $(touchStartItem).removeClass('touch-active');
        
        if (element && $(element).hasClass('match-item') && element !== touchStartItem) {
            const startSide = $(touchStartItem).attr('data-side');
            const endSide = $(element).attr('data-side');
            
            if (startSide === 'left' && endSide === 'right') {
                const leftId = $(touchStartItem).attr('data-item-id');
                const rightId = $(element).attr('data-item-id');
                
                if (connections[leftId]) {
                    removeConnection(leftId);
                }
                
                const existingConnection = Object.keys(connections).find(key => connections[key] === rightId);
                if (existingConnection) {
                    removeConnection(existingConnection);
                }
                
                createConnection(leftId, rightId);
                
                if (realTimeValidation) {
                    validateConnection(leftId, rightId);
                }
                
                updateProgress();
                setTimeout(() => checkAllConnections(), 300);
            }
        }
        
        touchStartItem = null;
    }
    
    // í‚¤ë³´ë“œ ì ‘ê·¼ì„±
    function handleKeydown(e) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            const side = $(this).attr('data-side');
            
            if (side === 'left') {
                handleLeftItemClick.call(this, e);
            } else if (side === 'right' && selectedLeft) {
                handleRightItemClick.call(this, e);
            }
        }
    }
    
    // ì¬ì œì¶œ ë²„íŠ¼ ì´ë²¤íŠ¸
    $(document).on('click', '#resubmit-btn', function() {
        if ('{{ slide.content_type.type_name }}' === 'line_matching') {
            resetLineQuiz();
        }
    });
    
    // ì´ˆê¸°í™” ì‹¤í–‰
    initializeLineQuiz();
});
</script>